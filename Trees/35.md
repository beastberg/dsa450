<a href="https://www.geeksforgeeks.org/problems/check-if-tree-is-isomorphic/1">Question 35</a>

### Isomorphic Trees

```cpp
class Solution {
  public:
    
    bool helper(Node* root1,Node* root2){
        if(!root1 && !root2) return true;
        if(!root1 || !root2) return false;
        if(root1->data != root2->data) return false;
        
        bool noSwap = helper(root1->left,root2->left) && helper(root1->right,root2->right);
        bool Swap = helper(root1->left,root2->right) && helper(root1->right,root2->left);
    
        return (noSwap || Swap);
    }
    
    bool isIsomorphic(Node *root1, Node *root2) {
        return helper(root1,root2);
    }
};
```

# Isomorphic Binary Trees Example

## ğŸŒ³ Example Trees:

**Tree 1 (root1):**
```
        1
       / \
      2   3
     / \
    4   5
       / \
      7   8
```

**Tree 2 (root2):**
```
        1
       / \
      3   2
         / \
        5   4
       / \
      8   7
```

These are isomorphic if we **swap**:
* root1's children: 2 and 3
* node 2's children: 4 and 5
* node 5's children: 7 and 8

## âœ… Base Cases

| Condition | Return |
|-----------|--------|
| Both nodes are `NULL` | `true` |
| One is `NULL`, other is not | `false` |
| Values of nodes don't match | `false` |

## ğŸªœ Simplified Recursive Calls (Step-by-step):

| Step | Comparing Nodes (root1, root2) | Match? | Swap Needed? | Result |
|------|--------------------------------|--------|--------------|--------|
| 1 | 1 vs 1 | âœ… | check children | move on |
| 2 | 2 vs 3 | âŒ | yes (swap) | check 3 vs 2 |
| 3 | 2 vs 2 | âœ… | yes | move on |
| 4 | 4 vs 4 | âœ… | no | âœ… |
| 5 | 5 vs 5 | âœ… | yes | move on |
| 6 | 7 vs 8 | âŒ | swap | check 7 vs 7 |
| 7 | 7 vs 7 | âœ… | no | âœ… |
| 8 | 8 vs 8 | âœ… | no | âœ… |
| 9 | 3 vs 3 | âœ… | no | âœ… |

**âœ… All paths return `true`, so the trees are isomorphic.**

## ğŸ§  Key Concept Recap:

We check two ways at each step:
1. **No Swap** â€“ compare left with left and right with right.
2. **Swap** â€“ compare left with right and right with left.

If **either** gives true â†’ the current nodes are 
isomorphic.

# Isomorphic Binary Trees - Recursive Call Stack Visualization

## ğŸŒ³ Tree Structures

**Tree 1:**
```
        1
       / \
      2   3
     / \
    4   5
       / \
      7   8
```

**Tree 2:**
```
        1
       / \
      3   2
         / \
        5   4
       / \
      8   7
```

## ğŸ“ Recursive Call Stack Analysis

### Call Stack Progression

```
Step 1: Initial Call
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â”œâ”€ Values: 1 == 1 âœ…                    â”‚
â”‚ â”œâ”€ Check children recursively           â”‚
â”‚ â””â”€ Status: ACTIVE                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 2: Left Child Call
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â””â”€ isIsomorphic(2, 3)                   â”‚
â”‚    â”œâ”€ Values: 2 != 3 âŒ                 â”‚
â”‚    â”œâ”€ Try without swap: FAILED          â”‚
â”‚    â”œâ”€ Try with swap: 2 vs 2             â”‚
â”‚    â””â”€ Status: ACTIVE                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: Swapped Comparison
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â””â”€ isIsomorphic(2, 3) [SWAP MODE]       â”‚
â”‚    â””â”€ isIsomorphic(2, 2)                â”‚
â”‚       â”œâ”€ Values: 2 == 2 âœ…              â”‚
â”‚       â”œâ”€ Check children recursively     â”‚
â”‚       â””â”€ Status: ACTIVE                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 4: Deep Recursion - Leaf Nodes
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â””â”€ isIsomorphic(2, 3) [SWAP MODE]       â”‚
â”‚    â””â”€ isIsomorphic(2, 2)                â”‚
â”‚       â”œâ”€ isIsomorphic(4, 4)             â”‚
â”‚       â”‚  â”œâ”€ Values: 4 == 4 âœ…           â”‚
â”‚       â”‚  â”œâ”€ Both leaf nodes             â”‚
â”‚       â”‚  â””â”€ Return: TRUE                â”‚
â”‚       â””â”€ isIsomorphic(5, 5)             â”‚
â”‚          â”œâ”€ Values: 5 == 5 âœ…           â”‚
â”‚          â”œâ”€ Check children recursively  â”‚
â”‚          â””â”€ Status: ACTIVE              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 5: Deeper Leaf Comparison
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â””â”€ isIsomorphic(2, 3) [SWAP MODE]       â”‚
â”‚    â””â”€ isIsomorphic(2, 2)                â”‚
â”‚       â”œâ”€ isIsomorphic(4, 4) â†’ TRUE      â”‚
â”‚       â””â”€ isIsomorphic(5, 5) [SWAP MODE] â”‚
â”‚          â”œâ”€ isIsomorphic(7, 7)          â”‚
â”‚          â”‚  â””â”€ Return: TRUE             â”‚
â”‚          â””â”€ isIsomorphic(8, 8)          â”‚
â”‚             â””â”€ Return: TRUE             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Step 6: Right Subtree
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ isIsomorphic(1, 1)                      â”‚
â”‚ â”œâ”€ isIsomorphic(2, 3) [SWAP] â†’ TRUE     â”‚
â”‚ â””â”€ isIsomorphic(3, 3)                   â”‚
â”‚    â”œâ”€ Values: 3 == 3 âœ…                 â”‚
â”‚    â”œâ”€ Both leaf nodes                   â”‚
â”‚    â””â”€ Return: TRUE                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Detailed Recursion Table

| Step | Call | Node1 | Node2 | Level | Comparison | Swap Mode | Result | Action |
|------|------|-------|-------|-------|------------|-----------|--------|--------|
| 1 | `isIsomorphic(1, 1)` | 1 | 1 | 0 | 1 == 1 âœ… | No | Pending | Check children |
| 2 | `isIsomorphic(2, 3)` | 2 | 3 | 1 | 2 != 3 âŒ | No | Failed | Try swap |
| 3 | `isIsomorphic(2, 2)` | 2 | 2 | 1 | 2 == 2 âœ… | Yes | Pending | Check children |
| 4 | `isIsomorphic(4, 4)` | 4 | 4 | 2 | 4 == 4 âœ… | No | âœ… TRUE | Leaf nodes |
| 5 | `isIsomorphic(5, 5)` | 5 | 5 | 2 | 5 == 5 âœ… | No | Failed | Try swap |
| 6 | `isIsomorphic(7, 7)` | 7 | 7 | 3 | 7 == 7 âœ… | Yes | âœ… TRUE | Leaf nodes |
| 7 | `isIsomorphic(8, 8)` | 8 | 8 | 3 | 8 == 8 âœ… | Yes | âœ… TRUE | Leaf nodes |
| 8 | `isIsomorphic(5, 5)` | 5 | 5 | 2 | - | Yes | âœ… TRUE | Children match |
| 9 | `isIsomorphic(2, 2)` | 2 | 2 | 1 | - | Yes | âœ… TRUE | Children match |
| 10 | `isIsomorphic(3, 3)` | 3 | 3 | 1 | 3 == 3 âœ… | No | âœ… TRUE | Leaf nodes |
| 11 | `isIsomorphic(1, 1)` | 1 | 1 | 0 | - | No | âœ… TRUE | All children match |

## ğŸ”„ Return Value Propagation

```
Level 3 (Deepest):
â”œâ”€ isIsomorphic(7, 7) â†’ TRUE
â””â”€ isIsomorphic(8, 8) â†’ TRUE

Level 2:
â”œâ”€ isIsomorphic(4, 4) â†’ TRUE
â””â”€ isIsomorphic(5, 5) â†’ TRUE (after swap: 7â†”8)

Level 1:
â”œâ”€ isIsomorphic(2, 2) â†’ TRUE (after swap: 2â†”3)
â””â”€ isIsomorphic(3, 3) â†’ TRUE

Level 0:
â””â”€ isIsomorphic(1, 1) â†’ TRUE (final result)
```

## ğŸ§  Algorithm Logic Flow

### Base Cases Checked:
1. **Both NULL**: `return true`
2. **One NULL**: `return false`  
3. **Values different**: Check swap possibility

### Recursive Cases:
1. **No Swap**: `isIsomorphic(left1, left2) && isIsomorphic(right1, right2)`
2. **With Swap**: `isIsomorphic(left1, right2) && isIsomorphic(right1, left2)`
3. **Final**: `return (noSwap || withSwap)`

## ğŸ“ˆ Memory Stack Usage

```
Maximum Stack Depth: 4 levels
â”œâ”€ Level 0: isIsomorphic(1, 1)
â”œâ”€ Level 1: isIsomorphic(2, 2) [swapped]
â”œâ”€ Level 2: isIsomorphic(5, 5) [swapped]
â””â”€ Level 3: isIsomorphic(7, 7) [swapped]

Total Function Calls: 11
Successful Comparisons: 8
Swap Operations Required: 3
```

## âœ… Final Result

**ğŸ¯ The trees ARE isomorphic!**

Required swaps to make Tree1 â†’ Tree2:
- Root level: Swap children of node 1 (2 â†” 3)
- Node 2 level: Swap children of node 5 (7 â†” 8)
- Final mapping: Tree1 structure matches Tree2 with swaps